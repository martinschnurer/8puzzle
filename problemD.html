<html>
<head>
	<title>Problem D</title>

	<style>
		.cube{
			height:50px;
			width:50px;
			background-color: #cec;
			cursor:pointer;
		}

		.inputik{
			height:50px;
			width:50px;
			background-color:#cec;
			box-shadow: none;
			border:none;
			text-align: center;
		}


	</style>



</head>


<body>
	<p>Zvolte dimension: <input id="dimension" type="number" style='width:50px;' onchange="recreate(this);"> </p>

	<div>
		<table id="matrix"></table>
	</div>

	<button onclick="startSimulation();">
		POTVRD
	</button>

	<script>
	var velke_cislo = 11*10*9*8*7*6*5*4*3*2 + 1;
	var m = 8;
	var iteracia = 0;
	var dimension = 3;
	var start = []; // TOTO JE ZACIATOCNA POZICIA Z KTOREJ SA ODSTARTUJE, TOTO SA MENI, KED SA HTML MATRIX MENI



	// AK SA V HTML ZMENI DIMENZIA, VYKRESLI SA ZNOVU HTML
	function recreate(element)
	{
		var value = element.value;
		var matrix = document.getElementById('matrix');
		
		start = [];
		dimension = parseInt(element.value);
		matrix.innerHTML = "";

		var row = "";

		for(var a=0;a<dimension*dimension;a++)
			start[a] = a+1;

		for(var a=0;a<value;a++)
		{
			row += "<tr>";
			for(var b=0;b<value;b++)
			{
				row += "<td><input class='inputik' val='"+(a*dimension+b+1)+"' type='number' value='"+(a*dimension+b+1)+"' onchange='changeValue(this);' row='"+a+"' column='"+b+"'></td>";
			}
		}
		matrix.innerHTML = row;
		console.log(start);
	}


	// AK SA ZMENI HODNOTA V MATRIXE, TAK TATO FUNKCIA SA SPUSTI
	function changeValue(element)
	{
		if(element.value == "")
			element.setAttribute("val","m");
		else
			element.setAttribute("val",element.value);

		var v 	   = element.getAttribute("val");
		var column = parseInt(element.getAttribute('column'));
		var row    = parseInt(element.getAttribute('row'));	
			
		start[row*dimension + column] = (v==="m") ? v : parseInt(v);
		console.log(start);

		return;
	}

	// OBJEKT SACHOVNICA, OBSAHUJE POLE A POZICIU MEDZERI
	var sachovnica = function(pole,pos)
	{
		this.pos = new Number(pos);			// novy objekt
		this.sachovnica  = pole.slice(0);	// novy objekt
		this.heuristika = new Number;		//novy objekt
		this.predchodca = undefined;	
		this.sucet = 65535;
		this.toDelete = 1;				// maximalny (nezmyselny) sucet 


		// PRVY VYPOCET HEURISTIKY
		this.firstHeuristic = function()
		{
			var sucet = 0;
			var cislo,x_prve,y_prve,x_cislo,y_cislo;

			for(var a=0;a<dimension*dimension;a++)
			{
				cislo = this.sachovnica[a];
				
				// A TOTO ROZHODNE KDE SA MA NACHADZAT TO DANE CISLO
				if(cislo === "m")
				{
					x_cislo = dimension-1;
					y_cislo = dimension-1;
				}
				else
				{
					x_cislo = (cislo-1) % dimension;
					y_cislo = Math.floor((cislo-1)/dimension);	
				}


				// ZE KDE SA MOMENTALNE NACHADZA
				x_prve = a % dimension;
				y_prve = Math.floor(a/dimension);
		

				sucet += Math.pow(x_prve - x_cislo,2) + Math.pow(y_prve - y_cislo,2); 

			}
			this.sucet  = sucet;
		}

		// DRUHY VYPOCET HEURISTIKY
		this.secondHeuristic = function()
		{
			var sucet = 0;

			for(a=0;a<dimension*dimension;a++)
			{
				if(this.sachovnica[a]!=(a+1))
					sucet++;
			}
			this.sucet = sucet;
		}

		//samotne pocitanie heuristiky po vytvoreni objektu
		this.firstHeuristic();
	}


	//popisuje rozne stavy
	//GLOBALNE PREMENNE
	var pocet_prvkov = 0;
	var velkost_tabulky = velke_cislo; 
	var hash_table = new Array(velkost_tabulky);
	var best_prvok = null;

	function insertToTable(sachovnica)
	{
		//console.log('inserting to table');
		pozicia = hash_compute(sachovnica) % velkost_tabulky;
		var i = 0;
		var o = 1;

		// pokracuj ak neni undefined a zaroven to neni ten hladany
		while( hash_table[pozicia] !== undefined && (i = porovnajPolia(hash_table[pozicia % velkost_tabulky],sachovnica)) == 0 ) 
			{
				pozicia=(++pozicia + (o++))%velkost_tabulky;
			}

		// AK TAM UZ JE TAK VRAT NULU (nepridali sme ziadny prvok)
		if(i)	
			return 0;	
		else
			hash_table[pozicia] = sachovnica; // ak tam nie je, pridaj do hash tabulky

		//inkrementuj pocet prvkov v tabulke
		pocet_prvkov++;
		

		// AK PREKROCIME HRANICU PRVKOV
		if(pocet_prvkov > 100000)
		{
			tmp = best_prvok;
			console.log(best_prvok);
			var zasobnik = [];
			var tmp_pocet = 0;

			// NASTAV KAZDEMU PRVKU V DOBREJ CESTE ABY SA NEVYMAZAL, ALE ABY SA PAMATAL V HASH TABLE
			while(tmp != undefined)
			{
				tmp.toDelete = 0;
				tmp = tmp.predchodca;
			}
			
			// VYMAZANIE PRVKOV AK PREKROCI ISTU HRANICU, NECHA LEN TU CESTU , KTORA VEDIE K NAJLEPSIEMU PRVKU
			for(var a=0;a<velkost_tabulky;a++)
			{
				// ak je node oznaceny, ze ma byt vymazany, vymaze sa
				if(hash_table[a] != undefined && hash_table[a].toDelete == 1)
				{
					hash_table[a] = undefined;
					pocet_prvkov--;
				}
				//AK SA MA ZAPAMATAT, TAK SA ULOZI DO ZASOBNIKA PRE REHESHOVANIE
				else if(hash_table[a] != undefined && hash_table[a].toDelete == 0)
				{
					zasobnik.push(hash_table[a]);
				}
			}

			//ZNOVU UMIESTNIT PRVKY V ZASOBNIKU DO TABULKY
			while(zasobnik.length)
			{
				var i,o = 1;
				var prvok = zasobnik.shift();
				pozicia = hash_compute(prvok);

				// UMIESTNIT PRVKY ZO ZASOBNIKA DO NOVOVYTVORENEJ TABULKY
				while( hash_table[pozicia] !== undefined && (i = porovnajPolia(hash_table[pozicia % velkost_tabulky],prvok)) == 0 ) 
				{	
					pozicia = (++pozicia + (o++))%velkost_tabulky;
				}
				
				hash_table[pozicia] = prvok;
			}
			
			// SIGNAL ze sa premazavala tabulka !!!
			return 2;
		}

		
		// SIGNAL ZE SA PRIDAL USPESNE PRVOK DO TABULKY BEZ PREMAZAVANIA
		return 1; // ak sa to tam uspesne vlozilo a este tam dany prvok nebol tak vrat 1
	}
	
	function hash_compute(sachovnica)
	{
		/**vypočíta sa HASH**/
		var n = sachovnica.sachovnica.length;
		var sucet = 0;
		for(var a = 0;a<n;a++)
		{
			if(sachovnica.sachovnica[a] == "m")
				sucet += 100*(a+1)*(a+1)*(a+1);
			else
				sucet += (a+1)*(a+1)*(a+1)*(a+1)*(sachovnica.sachovnica[a]+1)*(1+sachovnica.sachovnica[a])*(sachovnica.sachovnica[a]);
		}
		return sucet;
	}

	function porovnajPolia(Array1,Array2)
	{
		/**porovna dve polia, vrati 1 pokial sa rovnaju, 0 pokial sa nerovnaju**/
		var n = Array1.sachovnica.length;
		var ok = 1;
		for(a=0;a<n;a++)
		{
			if(Array1.sachovnica[a] !== Array2.sachovnica[a])
				return 0;
		}
		return 1;
	}

	function getValid(sach)
	{	
		/**VRATI POLE STRINGOV PRE VALID TAHY**/
		var x = sach.pos % dimension; 
		var y = Math.floor(sach.pos / dimension); 
		var pole = [];

		if(y != 0) 					pole.push("up");
		if(y != dimension-1)		pole.push("down");
		if(x != 0)					pole.push("left");
		if(x != dimension-1) 		pole.push("right");

		return pole;
	}

	function DOWN(sach)
	{
		var tmp = sach.sachovnica[sach.pos+dimension];
		var nova = new sachovnica(sach.sachovnica,sach.pos);
		nova.sachovnica[nova.pos+dimension] = "m"; 
		nova.sachovnica[nova.pos] = tmp;
		nova.pos += dimension;
		return nova;
	}
	function UP(sach){
		var tmp = sach.sachovnica[sach.pos-dimension];
		var nova = new sachovnica(sach.sachovnica,sach.pos);
		nova.sachovnica[nova.pos-dimension] = "m";
		nova.sachovnica[nova.pos] = tmp;
		nova.pos-=dimension;
		return nova;
	}
	function LEFT(sach){
		var tmp = sach.sachovnica[sach.pos-1];
		var nova = new sachovnica(sach.sachovnica,sach.pos);
		nova.sachovnica[nova.pos-1] = "m";
		nova.sachovnica[nova.pos] = tmp;
		nova.pos--;
		return nova;
	}
	function RIGHT(sach){
		var tmp = sach.sachovnica[sach.pos+1]; 
		var nova = new sachovnica(sach.sachovnica,sach.pos);
		nova.sachovnica[nova.pos+1] = "m";
		nova.sachovnica[nova.pos] = tmp;
		nova.pos++;
		return nova;
	}
	
	function findSolution(start,destination)
	{
		var neprehladane = [];
		neprehladane.push(start);
		
		var tmp;
		var choices;
		var validmoznosti;

		while(neprehladane.length)
		{
			// INKREMENTOVAT, KOLKO KRAT SA CYKLUS OPAKOVAL, AK PRILIS DLHO TAK SKONCI
			iteracia++;
			if(iteracia > 10000000)return 0;

			choices = [];
			
			// VYBER ZO ZASOBNIKA
			tmp = neprehladane.shift();

			// NAJST NAJLEPSI MOZNY PRVOK Z CYKLU , PO PREMAZANI TABULKY SA BUDE HLADAT OD TOHTO PRVKU
			if(best_prvok == undefined || best_prvok.sucet >= tmp.sucet)
				best_prvok = tmp;

			// vrati POLE STRINGOV napr. ["down","up"]
			validmoznosti = getValid(tmp); 

			// AK SME VYBRALI Z NEPREHLADANYCH STAVOV NAS VYSLEDNY TAH KTORY CHCEME NAJST, TAK SUPER, NASLI SME RIESENIE
			if(porovnajPolia(destination,tmp) == 1)
			{
				console.log('JUPII');
				console.log('pocet iteracii = '+iteracia);
				console.log(tmp);
				return tmp;
			}

			// VYTVORI SA POLE "Choices" DO KTOREHO SA ULOZIA NOVE SACHOVNICE KTORE SA VYGENEROVALI PO VALID TAHOCH
			for(var a = 0;a < validmoznosti.length ; a++)
			{
				if     ( validmoznosti[a] == "up"   )	choices.push(UP(tmp));	
				else if( validmoznosti[a] == "down" )	choices.push(DOWN(tmp));
				else if( validmoznosti[a] == "right")	choices.push(RIGHT(tmp));
				else if( validmoznosti[a] == "left" )	choices.push(LEFT(tmp));
			}


			// PRE KAZDU NOVU VYGENEROVANU SACHOVNICU SA ZISTI, CI UZ SME JU NAHODOU NEOBJAVILI, AK SME JU OBJAVILI TAK ULOZIT DO NEPREHLADANYCH STAVOV
			for(var b = 0; b < choices.length ;b++)
			{
				
				var i;
				if( (i=insertToTable(choices[b])) == 1) // AK ESTE NIE JE V HASH TABLE
					{
						if(neprehladane.length && choices[b].sucet < neprehladane[0].sucet ) // AK JE LEPSIA HEURISTIKA, PRIDAJ NA ZACIATOK FRONTU
							neprehladane.unshift(choices[b]);
						else
							neprehladane.push(choices[b]);   // AK NENI LEPSIA AKO PRVY ELEMENT,PRIDAJ NA KONIEC
						
						choices[b].predchodca = tmp; // vytvori sa odkaz na rodica
					}
				else if(i==2) // AK BOLA TABULKA PREMAZAVANA, TAK VYPRAZDNI FRONT, A UMIESTNI NA ZACIATOK NAJLEPSIEHO JEDINCA, KTORY MA NAJNIZSIU HEURISTIKU - BLIZSIE K CIELI
				{
					neprehladane = [];
					console.log(best_prvok);
					neprehladane.push(best_prvok);
					best_prvok.sucet++; // pridaj prvku heuristicky sucet + 1 , ak sa bude tento silny prvok opakovat, tak po istom case uz nebude najlepsi a zacne sa prehladavat ina cesta
					break;//znamena nepridavat dalsie CHOICES
				}

			}
			
		}

		return 0; // ak sa nenasla moznost
	}


	// JEDNODUCHE NAVRATENIE KU RODICOM A VYPISAT ICH
	function vypisPredchodcov(sachovnica)
	{
		var tmp = sachovnica;
		console.log('vypisovat idem');
		console.log(sachovnica);

		while(tmp != undefined)
		{
			console.log(tmp.sachovnica);
			tmp = tmp.predchodca;
		}

	}


	// TATO FUNKCIA SA SPUSTI PO STLACENI NA TLACIDLO BUTTON V HTML
	function startSimulation()
	{
		var tmp_array = [];
		for(var a=0;a<dimension*dimension - 1;a++)
		{
			tmp_array.push(a+1);
		}
		tmp_array.push("m");

		var destination = new sachovnica(tmp_array,dimension*dimension-1);
		var starting = null;
		for(var a=0;a<dimension*dimension;a++)
		{
			if(start[a] === "m")
			{	
				starting = new sachovnica(start,a);
				console.log('naslo sa m na pozicii '+a);
				break;
			}
		}

		insertToTable(starting);	
		var vysledna = findSolution(starting,destination);
		vypisPredchodcov(vysledna);
		window.alert('dokoncil som ulohu');
	}
	
	</script>

</body>


</html>